<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://womeimingzi11.github.io</id>
    <title>洗衣机&apos;s Blog</title>
    <updated>2020-03-08T13:44:38.697Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://womeimingzi11.github.io"/>
    <link rel="self" href="https://womeimingzi11.github.io/atom.xml"/>
    <subtitle>Why be a researcher if you can be an Engineer?</subtitle>
    <logo>https://womeimingzi11.github.io/images/avatar.png</logo>
    <icon>https://womeimingzi11.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 洗衣机&apos;s Blog</rights>
    <entry>
        <title type="html"><![CDATA[Using R for Everything: 使用 ggplot2 可视化新型冠状病毒肺炎在中国的确诊分布]]></title>
        <id>https://womeimingzi11.github.io/post/map_visualization_covid19_by_ggplot2/</id>
        <link href="https://womeimingzi11.github.io/post/map_visualization_covid19_by_ggplot2/">
        </link>
        <updated>2020-03-08T13:36:10.000Z</updated>
        <content type="html"><![CDATA[<p>这篇文章受到 Anisa Dhana 的博文 <a href="https://datascienceplus.com/map-visualization-of-covid19-across-world/">‘Map Visualization of COVID-19 Across<br>
the World with R’</a> 启发，尝试使用 R 语言绘制新冠肺炎 COVID-19 在国内的确诊、治愈和死亡地图。</p>
<h2 id="数据准备">数据准备</h2>
<h3 id="covid-19-data">COVID-19 Data</h3>
<p>绘制地图的第一步是收集数据。</p>
<p>首先，我们感谢约翰霍普金斯 CSSE <a href="https://data.humdata.org/dataset/novel-coronavirus-2019-ncov-cases">Johns Hopkins CSSE</a>, 他们将全球的疫情数据按照日期制作成了单一的 CSV 文件方便进行各类分析和统计。我们可以从 <a href="https://github.com/CSSEGISandData/COVID-19">Github</a> 页面获得需要的数据。</p>
<p>P.S. 非常建议大家直接使用 read_csv 从源 URL 直接获取数据，这样便于日后维护更新。但是因为个人原因，案例中使用下载至本地的 csv 作为数据源。此操作不影响后续的任务。</p>
<pre><code>library(tidyverse)

# Read the daily CSV file from Jons Hopkins CSSE I highly recommand to read_csv
# from url directly. But for my personal reason I have to download csv and read
# it from local path.

# df_origin &lt;-
# read_csv('http://raw.githubusercontent.com/CSSEGISandData/COVID-19/master/csse_covid_19_data/csse_covid_19_daily_reports/03-07-2020.csv')
df_origin &lt;- read_csv(&quot;03-07-2020.csv&quot;)

# Replace the slash into underline to make it easyily to filter
names(df_origin) &lt;- names(df_origin) %&gt;% str_replace_all(&quot;/&quot;, &quot;_&quot;)

# Keep the data of mainland and three regions of China
df_cov_china &lt;- filter(df_origin, Country_Region %in% c(&quot;Mainland China&quot;, &quot;Taiwan&quot;, 
    &quot;Hong Kong&quot;, &quot;Macao&quot;))

head(df_cov_china)

## # A tibble: 6 x 8
##   Province_State Country_Region `Last Update`       Confirmed Deaths Recovered
##   &lt;chr&gt;          &lt;chr&gt;          &lt;dttm&gt;                  &lt;dbl&gt;  &lt;dbl&gt;     &lt;dbl&gt;
## 1 Hubei          Mainland China 2020-03-07 11:13:04     67666   2959     43500
## 2 Guangdong      Mainland China 2020-03-07 10:43:02      1352      7      1237
## 3 Henan          Mainland China 2020-03-07 11:23:10      1272     22      1244
## 4 Zhejiang       Mainland China 2020-03-07 09:03:05      1215      1      1154
## 5 Hunan          Mainland China 2020-03-07 09:03:05      1018      4       960
## 6 Anhui          Mainland China 2020-03-06 03:23:06       990      6       979
## # ... with 2 more variables: Latitude &lt;dbl&gt;, Longitude &lt;dbl&gt;
</code></pre>
<h3 id="map-data">Map Data</h3>
<p>我们采用了包含两岸三地、藏南、阿克赛钦以及南海九段线的完整中华人民共和国的行政区划地图。这些数据将会托管在 Github 上进行分享，大家可以按需取用。</p>
<pre><code>library(rgdal)

# Read China Admistrative Area data from Shapefile.  To avoid the compatibility
# issue across systems, including Unix-like system and Windows. I highly
# recommand to use the file.path function to create the file paths.
map_cn_area &lt;- file.path(&quot;mapData&quot;, &quot;China_adm_area.shp&quot;) %&gt;% readOGR()

## OGR data source with driver: ESRI Shapefile 
## Source: &quot;C:\Users\chenh\OneDrive\Develop Learn\R\Map Visualization of COVID-19 Across China with R\mapData\China_adm_area.shp&quot;, layer: &quot;China_adm_area&quot;
## with 34 features
## It has 10 fields

# Conver the SpatialPolygonsDataFrame to DataFrame which can be held by ggplot2
df_cn_area &lt;- fortify(map_cn_area)

# Read the names of Province or region, and convert the name from PinYin to
# English.  This can match the Province name between WHO data and map data.
ls_province_name &lt;- map_cn_area@data$ID %&gt;% str_replace(&quot;Xianggang&quot;, &quot;Hong Kong&quot;) %&gt;% 
    str_replace(&quot;Aomen&quot;, &quot;Macao&quot;)

# The id is the unique serial to recongize the different province from map data.
ls_id &lt;- unique(df_cn_area$id)

# The orders of id and province name is all the same, the bind operation will
# combine the province name and id in different data.frame Use Proveince_State to
# Join data from WHO data and map data
df_final &lt;- df_cn_area %&gt;% left_join(bind_cols(Province_State = ls_province_name, 
    id = ls_id)) %&gt;% left_join(df_cov_china, by = &quot;Province_State&quot;)

# Read the boundary of provinces and regions from shapefile, it will be a
# SpatialLinesDataFrame
map_cn_bord &lt;- file.path(&quot;mapData&quot;, &quot;China_adm_bord.shp&quot;) %&gt;% readOGR()

## OGR data source with driver: ESRI Shapefile 
## Source: &quot;C:\Users\chenh\OneDrive\Develop Learn\R\Map Visualization of COVID-19 Across China with R\mapData\China_adm_bord.shp&quot;, layer: &quot;China_adm_bord&quot;
## with 1785 features
## It has 8 fields
## Integer64 fields read as strings:  FNODE_ TNODE_ LPOLY_ RPOLY_ BOU2_4M_ BOU2_4M_ID

df_cn_bord &lt;- fortify(map_cn_bord)
</code></pre>
<h2 id="数据可视化">数据可视化</h2>
<p>当所有的数据准备完成，便可以使用 ggplot2 进行可视化操作。使用 geom_polygon 来绘制不同行政区，因为数据类型是 <code>SpatialPolygonsDataFrame</code> 而使用 geom_path 来绘制行政区的边界，因为数据类型是<code>SpatialLinesDataFrame</code>。</p>
<p>我们需要额外考虑的问题是，因为武汉的患者数量数倍于国内其他区域范围内的患者数量，故此为了能够较为有层次的显示病患数量，我们将数据进行<em>平方根开方</em>处理。</p>
<pre><code>library(ggplot2)
# The group is unique serial of each province and region, in this case, it is
# similar with id.  Use geom_polygon to plot the area part, and use geom_path to
# plot the boundary part.  To make the data can be comparable, the patients in
# Hubei Province are multiple times than those in other provinces and regions,
# the data is root-square transformed.
ggplot() + geom_polygon(aes(x = long, y = lat, group = group, fill = sqrt(Confirmed)), 
    data = df_final) + geom_path(aes(x = long, y = lat, group = group), color = &quot;black&quot;, 
    data = df_cn_bord) + labs(caption = &quot;Data Repository provided by Johns Hopkins CSSE. Visualization by Han Chen&quot;) + 
    guides(fill = guide_legend(title = &quot;确诊人数\n（开平方处理）&quot;)) + theme(text = element_text(color = &quot;#22211d&quot;), 
    plot.background = element_rect(fill = &quot;#ffffff&quot;, color = NA), panel.background = element_rect(fill = &quot;#ffffff&quot;, 
        color = NA), legend.background = element_rect(fill = &quot;#ffffff&quot;, color = NA))
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://picgo-1256649726.cos.ap-chengdu.myqcloud.com/mapVisualization_confirmed-1.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Using R for Everything: 使用 ggplot2 绘制 RasterLayer 地图]]></title>
        <id>https://womeimingzi11.github.io/post/using-r-for-everything-shi-yong-ggplot2-hui-zhi-rasterlayer-di-tu/</id>
        <link href="https://womeimingzi11.github.io/post/using-r-for-everything-shi-yong-ggplot2-hui-zhi-rasterlayer-di-tu/">
        </link>
        <updated>2020-02-19T12:32:06.000Z</updated>
        <content type="html"><![CDATA[<p>Han (<a href="mailto:chenhan28@gmail.com" class="email">chenhan28@gmail.com</a>)<br>
在最近刚刚完成的一篇 SCI 文章中，为了描述实验的采样范围，通过 ggplot2 包 (Wickham et al. 2019) 将一组 RasterLayer 绘制成为了青藏高原的地形图。考虑到使用 R 绘制地图的中文内容较少，我们进行一次回顾。</p>
<p><strong>PS 因为不是地理方面的文章/专业，所以在专业性方面有欠缺，但对于自然科学类文章中进行展示基本上是足够了。</strong></p>
<h2 id="为什么用-ggplot2-画地图">为什么用 ggplot2 画地图？</h2>
<p><strong>因为我能！（摊手</strong></p>
<p>实际上原因如下：</p>
<ol>
<li>
<p>ggplot2 是非常强大的绘图工具，配合上 ggplot2 的衍生包，这套工具链基本能满足生态学领域几乎所有的绘图需求。</p>
</li>
<li>
<p>如果对 Photoshop 这类图像处理软件熟悉，就会发现使用 ggplot2 画图，逻辑上和 PS 是非常相似的，便于快速上手和修改生成的图像——天知道把英文图改成中文图有多烦人</p>
</li>
<li>
<p>此外相比于 ArcGIS 这类软件 R 这类跨平台软件几乎可以在任何环境下完成绘图任务，甚至可以在家中的机顶盒安装 R，只不过慢到天长地久而已。</p>
</li>
<li>
<p>免费免费免费</p>
</li>
</ol>
<p>在开始之前，先来看看最终的展示效果。<strong>为了避免文章版权和数据共享问题，地图上样点均去除，仅供参考。</strong></p>
<figure data-type="image" tabindex="1"><img src="https://picgo-1256649726.cos.ap-chengdu.myqcloud.com/gmap.jpg" alt="Demo without points" loading="lazy"></figure>
<h2 id="什么是-rasterlayer">什么是 RasterLayer？</h2>
<p>关于 RasterLayer 的定义，在 <a href="https://rspatial.org/raster/spatial/4-rasterdata.html">Spatial Data Science (Feed the Future n.d.)</a> 中有很好的解释。</p>
<blockquote>
<p>A RasterLayer object represents single-layer (variable) raster data. A<br>
RasterLayer object always stores a number of fundamental parameters<br>
that describe it. These include the number of columns and rows, the<br>
spatial extent, and the Coordinate Reference System. In addition, a<br>
RasterLayer can store information about the file in which the raster<br>
cell values are stored (if there is such a file). A RasterLayer can<br>
also hold the raster cell values in memory.</p>
</blockquote>
<p>在 R 中提及的 RasterLayer 通常指的是由 sp 包 (Pebesma et al. 2019) 提供的 RasterLayer 类，每一个 RasterLayer 代表一层 raster 栅格数据，其中记录了 raster 数据的基础信息，例如行、列、空间范围、参考系。而对 RasterLayer 进行操作最常用的工具是 raster 包 (Hijmans et al. 2020)。</p>
<h2 id="数据准备">数据准备</h2>
<p>所需加载包： 1. <code>elevatr</code>(Hollister and Shah 2018)；2. <code>raster</code>； 3.<code>tidyverse</code> (Wickham and RStudio 2019)</p>
<p>具体到这一次的地图绘制中，我们需要<strong>两个</strong> RasterLayer —— 1. 作为背景层的 <code>bg_rst</code>，以及 2.用作展示地形的 <code>tp_rst</code>。那么如何获得这两个 RasterLayer 呢？<code>elevatr</code> 包提供了专门用于获取高程栅格数据的方法 <code>get_elev_raster</code>.</p>
<p>不过在获取高程数据之前，需要首先指定地图绘制矩形边界。之后方可使用 <code>get_elev_raster</code> 来获取边界范围内的高程数据，使用 <code>z</code> 参数 (zoom) 确定缩放程度。因为通过 <code>get_elev_raster</code> 获取高程 raster 的方法是获取服务器与自定义边界的最小公倍数（不准确的说法），所以需要对获取的原始 RasterLayer 再次剪切，以便得到地图绘制矩形边界内的数据。</p>
<pre><code class="language-r">library(elevatr)  # Get rasterlay from AWS by `get_elev_raster` fucntion
library(raster)  # Manipulate RasterLayer object
library(tidyverse)  # Tidy is everything.

# Set the extent we want to plot
ext_sample &lt;- extent(70, 105, 25, 45)

# Preparing for getting the elevation raster data, make a blank RasterLayer,
# becasue the first parameter of get_elev_raster is a target Rasterlayer.
bg_init &lt;- raster(ext = ext_sample, resolution = 0.01)
# Get elevation raster with zoom 5, then only keep the extend we want to plot
# later.
bg_rst &lt;- get_elev_raster(bg_init, z = 5) %&gt;% crop(ext_sample)
</code></pre>
<p><code>bg_rst</code> 就是地图背景中灰色的辅助部分的数据就准备好了。</p>
<pre><code class="language-r"># Let's check the detail of bg_rst, the Background RasterLayer
bg_rst
</code></pre>
<pre><code>## class      : RasterLayer 
## dimensions : 1075, 1591, 1710325  (nrow, ncol, ncell)
## resolution : 0.022, 0.0186  (x, y)
## extent     : 70.008, 105.01, 25.0029, 44.9979  (xmin, xmax, ymin, ymax)
## crs        : +proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0 
## source     : /private/var/folders/0s/pkk0623j6dgdq9yyg4d3qtq40000gn/T/RtmpUCKkKF/raster/r_tmp_2020-02-21_223346_8889_78742.grd 
## names      : layer 
## values     : -156.1392, 8006.811  (min, max)
</code></pre>
<p>随后我们需要下载青藏高原的多边形文件，这里我们选择张镱锂 (2002) 等人在《论青藏高原范围与面积》一文提供的青藏高原范围与界线地理信息系统数据。从<a href="http://www.geodoi.ac.cn/WebCn/doi.aspx?Id=135">《全球变化科学研究数据出版系统》</a>下载即可。这里我选择了 <code>DBATP.zip</code> 下载，对应的文件格式为 Shaplefile，使用 rgdal 包 (Bivand et al. 2019) 提供的 <code>readOGR</code> 方法读取其中的 <code>DBATP_Polygon.shp</code>，保存的数据类型为<code>tp_ext</code>（类型为 SpatialPolygonsDataFrame）。之后将<code>bg_rst</code> 数据按照 <code>tp_ext</code> 形状进行处理，获得符合青藏高原范围的 RasterLayer <code>tp_rst</code>。</p>
<pre><code class="language-r">library(rgdal)
# Read the SpatialPolygon File from DBATP_Polygon.shp
tp_ext &lt;- readOGR(&quot;DBATP/DBATP_Polygon.shp&quot;)
</code></pre>
<pre><code>## OGR data source with driver: ESRI Shapefile 
## Source: &quot;/Users/chenhan/Documents/Develop Learn/R/plotMapByGGplot/DBATP/DBATP_Polygon.shp&quot;, layer: &quot;DBATP_Polygon&quot;
## with 1 features
## It has 1 fields
</code></pre>
<pre><code class="language-r"># Keep the shpae of the Tibetan Plateau
tp_rst &lt;- mask(bg_rst, tp_ext)
</code></pre>
<p>为了便于定位，我们还将在图片上绘制地标名称 <code>city_ls</code>，以及采样点位置及其类型 <code>hbt_coord</code>。</p>
<p>PS.可以根据自己的实际情况确定数据的存储类型，这里因为个人项目的实际情况，数据并没有保存成为常见的 data.freame 或者 tibble 之类的类表格形式。<strong>注意绘图过程中前后对应即可</strong>。</p>
<pre><code class="language-r"># Create the list of landmarks which we want to mark
city_ls &lt;- list(x = c(91.1, 86.925278, 101.7781), y = c(29.65, 27.988056, 36.6169), 
    label = c(&quot;Lhasa&quot;, &quot;Qomolangma&quot;, &quot;Xi'Ning&quot;))
str(city_ls)
</code></pre>
<pre><code>## List of 3
##  $ x    : num [1:3] 91.1 86.9 101.8
##  $ y    : num [1:3] 29.6 28 36.6
##  $ label: chr [1:3] &quot;Lhasa&quot; &quot;Qomolangma&quot; &quot;Xi'Ning&quot;
</code></pre>
<pre><code class="language-r"># Read point with latitude and longitude. This operation is not needed for
# everyone, actually it depends on the actual data structure.
hbt_coord &lt;- read_rds(&quot;hbt_coord.rds&quot;) %&gt;% mutate(Ecosystem = ifelse(hbt == &quot;M&quot;, 
    &quot;Alpine Meadow&quot;, &quot;Alpine Steppe&quot;))
str(hbt_coord)
</code></pre>
<pre><code>## Classes 'tbl_df', 'tbl' and 'data.frame':    432 obs. of  4 variables:
##  $ hbt      : chr  &quot;M&quot; &quot;M&quot; &quot;M&quot; &quot;M&quot; ...
##  $ lon      : num  101 101 101 100 100 ...
##  $ lat      : num  35.3 35 35 34.5 34.5 ...
##  $ Ecosystem: chr  &quot;Alpine Meadow&quot; &quot;Alpine Meadow&quot; &quot;Alpine Meadow&quot; &quot;Alpine Meadow&quot; ...
</code></pre>
<p><strong>注意</strong>，前面的操作中，我们裁剪 RasterLayer 用到了 crop 和 mask 两种操作，关于这两种操作的解释，我用一张图来解释：</p>
<figure data-type="image" tabindex="2"><img src="https://picgo-1256649726.cos.ap-chengdu.myqcloud.com/JPEG%E5%9B%BE%E5%83%8F-606FC26ACE54-1.jpeg" alt="Differences between crop andmask" loading="lazy"></figure>
<p>简而言之，两种操作都会得到更小的矩形图形，但是使用 mask 方法会在多边形区域外的矩形部分填充 NA 使被裁剪 RasterLayer 看起来成为多边形。</p>
<h2 id="地图绘制">地图绘制</h2>
<p>所需加载包： <code>scales</code> (Wickham, Seidel, and RStudio 2019)</p>
<p>不过在进行绘图之前，还需要对 RasterLayer 数据进行一些小的调整，以便与 <code>ggplot2</code> 的功能兼容。首先将两个 RasterLayer 转换为 data.frame 保留 xy，xy 为经纬度，应点上的值将会保留成与 RasterLayer 中 names 相同的列名，比如 <code>bg_rst</code> 转换为 data.frame 后列名就是 x, y, layer。之后我们将 layer（在此处为当前为止的海拔高度）转换数值范围，因为保留原始的数据用作后面的透明度会让整张图像灰蒙蒙。</p>
<p>不过要注意的是，正如我们前面说到的 mask 后的 RasterLayer 会将区域外的数据标记为 NA，如果直接使用 NA 绘图将会出现各种奇怪的效果，因此我们选择将 NA 数据更换为 0，将区域内的数据更换为 1，将两种值用作图像的 alpha 就会绘制出准确的青藏高原样式。</p>
<p>没看懂咋办？呆胶布！动手试试不进行 NA 转换的效果便知道了。</p>
<pre><code class="language-r"># scales package provide rescale function which can convert the range of numbers
# list to another range.
library(scales)
</code></pre>
<pre><code>## 
## Attaching package: 'scales'

## The following object is masked from 'package:purrr':
## 
##     discard

## The following object is masked from 'package:readr':
## 
##     col_factor
</code></pre>
<pre><code class="language-r"># First convert RasterLayer as Data.Frame with xy coordinate system.  Then
# rescale the elevaion to alpha, as the background part, super high alpha value
# is not a good idea, which range is the best? It depends by the actual. Save the
# alpha value with colname 'alpha'
bg_rst_df &lt;- as.data.frame(bg_rst, xy = TRUE) %&gt;% mutate(alpha = rescale(layer, to = c(0.25, 
    0.75)))

# NA will be generated by the mask function, if use NA and evelation as the alpha
# of Topographic figure, it will be dizzy, and for color Topographic figure
# please don't use the greyscale and color for the evelation simultaneously. Just
# use alpha to control the shape of regional shpae.
tp_rst_df &lt;- as.data.frame(tp_rst, xy = TRUE) %&gt;% mutate(alpha = ifelse(is.na(layer), 
    0, 1))
</code></pre>
<p>当数据准备完毕，我们就开始图形的绘制。首先进行地形图叠加到背景地形的绘制。因为命令较多，并且均以注释的形式标注到代码中，故此不再提前讲解。</p>
<pre><code class="language-r"># sacle_parm as a parameter controls the sclae of the hole figure, it will be
# used to control the size of text, point, legend, etc. to fit the size of
# figure.
scale_parm &lt;- 2
# Init ggplot
gmap &lt;- ggplot() + # plot the backgroun layer, set the alpha without color will make a grey
# background
geom_raster(data = bg_rst_df, aes(x = x, y = y, alpha = alpha)) + # plot the topographic layer, set alpha to keep the shape of Tibetan Plateau
# (TP). Color indicates the elevation.
geom_raster(data = tp_rst_df, aes(x = x, y = y, fill = layer, alpha = alpha)) + # terrain.colors is an built-in function to generate a list of color palettes.
# set the legend title of evelation by name parameter.
scale_fill_gradientn(colours = terrain.colors(100), name = &quot;Elevation (m)&quot;) + # As we said before, the alphas is used to determine the shpae of TP, we don't
# need to show them as legends.
scale_alpha(guide = &quot;none&quot;) + # Project this figure as a map but not a normal figure
coord_quickmap() + # Set preset theme makes things easire
theme_minimal() + # Set the limititions of axes. `expand` parameter will remove the gaps between
# the rectangle map and axes.  If you are not sure what's this mean, remove the
# parameter by yourself and you will find it out.
scale_x_continuous(limits = c(70, 105), expand = c(0, 0)) + scale_y_continuous(limits = c(25, 
    45), expand = c(0, 0)) + # Set the titles of axis
labs(x = &quot;Longtitude (E)&quot;, y = &quot;Laitude (N)&quot;) + # remove the background color and background grid, you know the classical
# ggplot's grid, don't you?
theme(panel.grid = element_blank(), panel.background = element_blank()) + # Set the size of axis and legend
theme(axis.title = element_text(size = 7 * scale_parm), axis.text = element_text(size = 6 * 
    scale_parm)) + theme(legend.key.width = unit(0.2 * scale_parm, &quot;cm&quot;), legend.key.height = unit(0.5 * 
    scale_parm, &quot;cm&quot;), legend.text = element_text(size = 5 * scale_parm), legend.title = element_text(size = 6 * 
    scale_parm))

# Preview will slow down the process of operations, I highly recommand do not
# preveiw the ggplot and save it as a file directly.
</code></pre>
<p>上述操作完毕，如果没有意外，就可以获得一张效果尚可的底图了。但是，个人强烈建议不进行预览图像，直接进行后续的操作，因为绘制当前精度的底图需要花费较长的时间。或者可以使用 <code>ggsave</code> 方法输出为文件进行预览，这样如果效果满意，可以直接用作成品，避免预览后再次绘制效率较低。</p>
<p>随后我们再将地标为止添加到底图上。</p>
<pre><code class="language-r">gmap &lt;- gmap +
  # Add the city_ls to the main plot as landmarks.
  geom_text(
    mapping = aes(x = x, y = y, label = label),
    # geom_text don't support the structure we used. 
    # convert the list into data.frame, every element is used as column here.
    data = bind_cols(city_ls),
    size = 2 * scale_parm
  )
</code></pre>
<p>最后将采样点添加到底图上。注意 ⚠️ 由于版权和数据分享的原因，我将采样点的坐标设置为 0，0，故此图片上不会显示任何采样点，请根据实际情况设置！</p>
<pre><code class="language-r">gmap &lt;- gmap +
  # Add the sample sites to the main plot as points.
  # Due to the copyright of my scholar article and data share policy, I won't point my sample sites to the picuture, the coordinations of point is 0,0 here.
  geom_point(
    mapping = aes(
      # x = lon,
      x = 0,
      y = 0,
      # y = lat,
      col = Ecosystem,
      shape = Ecosystem
    ),
    data = hbt_coord,
    # Don't set the size as 0 until you don't want to see anything here.
    # Don't set the size as 0 until you don't want to see anything here.
    # Don't set the size as 0 until you don't want to see anything here.
    size = 0 * scale_parm
  ) +
  # Convert the color as legend class, becasuse the shape legend is legend class.
  # If there is no class conversion, the shape and color will be showed as two legends.
  # Then select colour as guides and site a larger size to make it more readable.
  # Don't know what's these means? Commit below code will show you everything.
  scale_color_discrete(guide = &quot;legend&quot;) +
  guides(colour = guide_legend(override.aes = list(size = .8 * scale_parm)))
</code></pre>
<p>如果对输出结果满意，那么可以跳过下面这一步，直接进行 <code>ggsave</code> 操作保存图像。不过在这里，保存图像之前，我们还需要修改图片的空白区域 margins 来让图像更合适一些。</p>
<pre><code class="language-r">gmap &lt;- gmap +
  theme(plot.margin =
          # Set marigns of figure, the order of parameters is top, right, bottom, left
          unit(
            c(0 * scale_parm, 0 * scale_parm, -.2 * scale_parm, .2 * scale_parm),
            &quot;cm&quot;
          ))
</code></pre>
<p>最后导出图像即可。<code>ggsvae</code> 提供了丰富的参数定义输出的图像。对于需要投稿 SCI 的文章，通常 Author Guidelines 要求提供不低于 300 DPI 的图片文件。如果允许，保存为 PDF 文件会是不错的方法，毕竟通用性和文件大小都能得到很好的满足。</p>
<pre><code class="language-r">ggsave(filename = &quot;gmap.pdf&quot;, plot = gmap, width = 9 * scale_parm, height = 6.2 * 
    scale_parm, units = &quot;cm&quot;, dpi = 600)
</code></pre>
<pre><code>## Warning: Removed 432 rows containing missing values (geom_point).
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://picgo-1256649726.cos.ap-chengdu.myqcloud.com/gmap.jpg" alt="" loading="lazy"></figure>
<p>最后，如果有任何更好的意见和建议，换用通过任何形式与我交流。祝大家都能制作出令自己（主要是杂志）满意的作品。</p>
<h2 id="参考文献">参考文献</h2>
<div id="refs" class="references hanging-indent" markdown="1">
<div id="ref-bivand_rgdal_2019" markdown="1">
<p>Bivand, Roger, Tim Keitt, Barry Rowlingson, Edzer Pebesma, Michael Sumner, Robert Hijmans, Even Rouault, Frank Warmerdam, Jeroen Ooms, and Colin Rundel. 2019. “Rgdal: Bindings for the ’Geospatial’ Data Abstraction Library.” <a href="https://CRAN.R-project.org/package=rgdal">https://CRAN.R-project.org/package=rgdal</a>.</p>
</div>
<div id="ref-feed_the_future_raster_nodate" markdown="1">
<p>Feed the Future. n.d. “Raster Data — R Spatial.” Blog. <em>Spatial Data Science</em>. Accessed February 19, 2020. <a href="https://rspatial.org/raster/spatial/4-rasterdata.html">https://rspatial.org/raster/spatial/4-rasterdata.html</a>.</p>
</div>
<div id="ref-hijmans_raster_2020" markdown="1">
<p>Hijmans, Robert J., Jacob van Etten, Michael Sumner, Joe Cheng, Andrew Bevan, Roger Bivand, Lorenzo Busetto, et al. 2020. “Raster: Geographic Data Analysis and Modeling.” <a href="https://CRAN.R-project.org/package=raster">https://CRAN.R-project.org/package=raster</a>.</p>
</div>
<div id="ref-hollister_elevatr_2018" markdown="1">
<p>Hollister, Jeffrey, and Tarak Shah. 2018. “Elevatr: Access Elevation Data from Various APIs.” <a href="https://github.com/jhollist/elevatr">https://github.com/jhollist/elevatr</a>.</p>
</div>
<div id="ref-pebesma_sp_2019" markdown="1">
<p>Pebesma, Edzer, Roger Bivand, Barry Rowlingson, Virgilio Gomez-Rubio, Robert Hijmans, Michael Sumner, Don MacQueen, Jim Lemon, Josh O’Brien, and Joseph O’Rourke. 2019. “Sp: Classes and Methods for Spatial Data.” <a href="https://CRAN.R-project.org/package=sp">https://CRAN.R-project.org/package=sp</a>.</p>
</div>
<div id="ref-wickham_ggplot2_2019" markdown="1">
<p>Wickham, Hadley, Winston Chang, Lionel Henry, Thomas Lin Pedersen, Kohske Takahashi, Claus Wilke, Kara Woo, Hiroaki Yutani, and RStudio. 1.    “Ggplot2: Create Elegant Data Visualisations Using the Grammar of Graphics.” <a href="https://CRAN.R-project.org/package=ggplot2">https://CRAN.R-project.org/package=ggplot2</a>.</p>
</div>
<div id="ref-wickham_tidyverse_2019" markdown="1">
<p>Wickham, Hadley, and RStudio. 2019. “Tidyverse: Easily Install and Load<br>
the ’Tidyverse’.” <a href="https://CRAN.R-project.org/package=tidyverse">https://CRAN.R-project.org/package=tidyverse</a>.</p>
</div>
<div id="ref-wickham_scales_2019" markdown="1">
<p>Wickham, Hadley, Dana Seidel, and RStudio. 2019. “Scales: Scale Functions for Visualization.” <a href="https://CRAN.R-project.org/package=scales">https://CRAN.R-project.org/package=scales</a>.</p>
</div>
<div id="ref-__2002" markdown="1">
<p>张镱锂, 李炳元, and 郑度. 2002. “论青藏高原范围与面积.” <em>地理学报</em> 21 (1): 1–8. <a href="https://doi.org/10.11821/yj2002010001">https://doi.org/10.11821/yj2002010001</a>.</p>
</div>
</div>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[N1-PT下载小钢炮固件安装说明（转载自荒野无灯）]]></title>
        <id>https://womeimingzi11.github.io/post/ph1-n1-xiaogangpao/</id>
        <link href="https://womeimingzi11.github.io/post/ph1-n1-xiaogangpao/">
        </link>
        <updated>2019-12-27T06:20:35.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>Source: <a href="http://rom.nanodm.net/N1/n1-fw-install-guide.md">http://rom.nanodm.net/N1/n1-fw-install-guide.md</a></p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>Source: <a href="http://rom.nanodm.net/N1/n1-fw-install-guide.md">http://rom.nanodm.net/N1/n1-fw-install-guide.md</a></p>
</blockquote>
<!-- more -->
<html>
<head><meta charset="utf-8">
<title></title>
<link href="https://api.nanodm.net/assets/gfm.css" media="all" rel="stylesheet" type="text/css" />
<link href="//cdn.bootcss.com/octicons/2.1.2/octicons.min.css" media="all" rel="stylesheet" type="text/css" />
</head>
<body>
<article class="markdown-body entry-content" style="padding: 30px;"><h1><a name="nano-disk-manager-nanodm" class="anchor" href="#nano-disk-manager-nanodm" rel="nofollow" aria-hidden="true"><span class="octicon octicon-link"></span></a>Nano Disk Manager (NanoDM)</h1>
<h1><a name="n1-pt下载小钢炮固件安装说明" class="anchor" href="#n1-pt%E4%B8%8B%E8%BD%BD%E5%B0%8F%E9%92%A2%E7%82%AE%E5%9B%BA%E4%BB%B6%E5%AE%89%E8%A3%85%E8%AF%B4%E6%98%8E" rel="nofollow" aria-hidden="true"><span class="octicon octicon-link"></span></a>
N1 PT下载小钢炮固件安装说明</h1>
<p>本说明最后由 荒野无灯 于 2019-04-24 17:38 编辑</p>
<p>公测版由于功能尚未最终稳定。因此，更新会比较频繁。</p>
<p>强烈建议使用0411之后的版本, 不要再去下载0909版本了...</p>
<p>0909版本的任何问题或bug都不予处理.</p>
<h2><a name="faq" class="anchor" href="#faq" rel="nofollow" aria-hidden="true"><span class="octicon octicon-link"></span></a>
FAQ</h2>
<p>缓存问题 (此问题仅存在于0909及之前的老固件):</p>
<p>如果你进某个页面总是跳回登录页面,或者直接没有显示任何东西
，浏览器返回的是该页无法显示。</p>
<p>chrome浏览器缓存问题。 ctrl + shift + i , 然后右击浏览器顶部地址栏的刷新按钮，</p>
<p>选择第三项：“清空缓存并硬性重新加载”， 即可。</p>
<p>更多FAQ见： <a href="https://gitee.com/8ox86/phicomm-n1-issue" rel="nofollow">https://gitee.com/8ox86/phicomm-n1-issue</a></p>
<p>====================================================================================</p>
<h2><a name="从n1原版android系统刷机操作步骤" class="anchor" href="#%E4%BB%8En1%E5%8E%9F%E7%89%88android%E7%B3%BB%E7%BB%9F%E5%88%B7%E6%9C%BA%E6%93%8D%E4%BD%9C%E6%AD%A5%E9%AA%A4" rel="nofollow" aria-hidden="true"><span class="octicon octicon-link"></span></a>
从n1原版android系统刷机操作步骤</h2>
<p>1.有一个N1,准备个U盘. 不要太大，U盘大于512M即可. usb 2.0的最佳。</p>
<p>闪迪（SanDisk）酷豆（CZ33）16GB 或 8GB的测试通过，表现良好。lexar 8GB USB2.0
U盘表现更佳。</p>
<p>经测试，上次撸的台电（Teclast）锋芒 U盘 64G USB3.0很大概率上识别会有问题。</p>
<ol>
<li>下载 phicomm-n1-s905-linux-hacklog-20190327-0136.img.7z ,
用<code>7z</code>或<code>winrar</code>解压后,再校验img文件的md5.</li>
</ol>
<p>注意校验md5 phicomm-n1-s905-linux-hacklog-20190327-0136.md5sum.txt</p>
<ol>
<li>将镜像文件 phicomm-n1-s905-linux-hacklog-20190327-0136.img
通过工具写入U盘</li>
</ol>
<p>(windows下可用<code>USB Image Tool</code>或etcher[<a href="https://etcher.io]%EF%BC%8C" rel="nofollow">https://etcher.io]，</a> linux
gnome3环境下可直接用Disks工具写入)</p>
<p><strong>关于img写入</strong></p>
<p>推荐使用<a href="http://rom.nanodm.net/N1/tool/usb-image-tool.zip" rel="nofollow">usb-image-tool</a>
写入 其它工具没有测试过.不保证其工作正常. 如果你下载的是一个.xz的文件,请解压出
.img文件出来,并校对 .img文件的md值. 然后再行写入. 写入方法详细步骤:
<a href="http://rom.nanodm.net/N1/%E8%8D%92%E9%87%8E%E6%97%A0%E7%81%AFN1%E5%9B%BA%E4%BB%B6img%E5%86%99%E5%85%A5%E6%95%99%E7%A8%8Bfor%20windows%20users.zip" rel="nofollow">荒野无灯N1固件img写入教程for windows users.zip</a></p>
<p>U盘写好后，先别插入！ U盘写好后，先别插入！ U盘写好后，先别插入！</p>
<ol>
<li>N1插上网线连接到路由器（路由器要支持DHCP）,N1开机，打开adb远程调试.</li>
</ol>
<p>(关于如何打开adb，这里我说明一下，接显示器和鼠标，进入原装的N1系统，然后点击版本号4次，提示adb已经打开即可。这个时候，即使你断电，下次开机，会也是adb已经开启的状态。)</p>
<p>N1成功获取到IP后，在路由器Client
   Status你可以看到类似android-a08558xxxx这种名称的机器.</p>
<ol>
<li>N1通过adb连接n1，这里假设我们获取到的N1的IP为: 192.168.8.201,
在电脑端执行命令：</li>
</ol>
<p><code>adb connect 192.168.8.201</code> (这里为盒子的IP）,连接成功后你会看到提示：
   <code>connected to 192.168.6.201:5555</code></p>
<p>这一步如果没有连接成功,你后面的不用看了...</p>
<ol>
<li><p>前提：必须保证第5步你adb连接成功了！(这时可连接显示器看效果,但不是必须的),输入:</p>
<pre><code>adb shell
</code></pre></li>
</ol>
<p>确保已经进入android的shell,成功进入的标记是，命令提示符会变成： <code>p230:/ $</code>
然后手里准备好U盘，再执行：</p>
<pre><code>reboot update
</code></pre>
<p>此时，迅速插上U盘到离HDMI口最近的那个位置。只插一个U盘,不要插其它多余的USB...</p>
<p>如果命令执行成功,且你的U盘是做好的,那么,会自动进入linux系统(没错,我还没想好名字,先叫linux吧),</p>
<p>然后你如果接了显示器的话,应该是始终黑屏的. 反之,如果不是黑屏,而是进入了盒子系统的画面,</p>
<p>或者进入了盒子的recovery界面,</p>
<p>说明你的U盘做得有问题,换U盘,或者检查自己制作启动盘的过程是不是存在问题.</p>
<ol>
<li>进入老毛子路由器，打开Client
Status（客户端状态）列表，点击刷新。等待N1启动后获取IP,
你会看到一个名为phicomm-n1的机器，</li>
</ol>
<p>N1 的mac 开头是 <code>FC7C02</code> 的。</p>
<p>这里假设N1的IP为: <code>192.168.8.201</code>， 后续的说明以这个假设为基础。</p>
<p>启动大概需要两三分钟。</p>
<ol>
<li>安装到内置emmc: 通过浏览器打开 <code>http://192.168.8.201:8086/</code>
，即可看到安装界面。</li>
</ol>
<p>然后,点击<code>start install</code>按钮即可开始自动安装。</p>
<p>如果有看到<code>socket ignored</code>的错误,不用管.其它操作成功就行.</p>
<p>最后显示：<code>Complete copy OS to eMMC parted SYSTEM</code>
即表示安装过程已经完成。此时，</p>
<p>可气沉丹田，蛋定，然后，断掉N1电源, 拔掉U盘。</p>
<p>再上电开机即可。</p>
<ol>
<li>静静地等待启动。大概两三分钟吧。</li>
</ol>
<p>查看IP可以用上面提到的”Client Status（客户端状态）列表“ 法。
（也可以用ping，一般是没必要的。）</p>
<ol>
<li>打开登录页面后，务必清空chrome浏览器缓存。</li>
</ol>
<p>ctrl + shift + i , 然后右击浏览器顶部地址栏的刷新按钮，</p>
<p>选择第三项：“清空缓存并硬性重新加载”， 即可。</p>
<p>此操作在更新完系统或更新完dashboard后务必执行一次。</p>
<ol>
<li><p>如何判断刷机是正常的？登录dashbaord后，最多等待2分钟时间,然后：</p>
<p>依次点击左侧菜单的apps下面的菜单：</p>
<pre><code>qBittorrent: 绿色Running
Transmission: 绿色Running
Aria2: 绿色Running
Samba: 绿色Running
FRP: 绿色Running
ftp server: 绿色Running
filemanager: 绿色Running
syncthing: 绿色Running
</code></pre>
<p>如果所有服务不是全绿的状态。说明刷机是有问题的。</p>
<p>可以重新写盘，再刷一次。这时不必按这个步骤来了，</p>
<p>而是参照下面的”从本固件旧版系统刷机操作步骤“</p>
<p>jellyfin和docker默认没有自启动，因此是stopped 状态, 这是正常的.</p></li>
<li><p>刷机完成后，重启一次。</p></li>
</ol>
<p>====================================================================================</p>
<h2><a name="从本固件旧版系统刷机操作步骤" class="anchor" href="#%E4%BB%8E%E6%9C%AC%E5%9B%BA%E4%BB%B6%E6%97%A7%E7%89%88%E7%B3%BB%E7%BB%9F%E5%88%B7%E6%9C%BA%E6%93%8D%E4%BD%9C%E6%AD%A5%E9%AA%A4" rel="nofollow" aria-hidden="true"><span class="octicon octicon-link"></span></a>
从本固件旧版系统刷机操作步骤</h2>
<ol>
<li><p>配置备份 (具体方法见下面的&#34;配置的备份和恢复&#34;)</p></li>
<li><p>下载img文件写入U盘</p></li>
<li><p>关机，插入U盘，上电， 等待从U盘启动</p></li>
<li><p>通过浏览器打开 <a href="http://192.168.8.201:8086/" rel="nofollow">http://192.168.8.201:8086/</a>
，安装固件到emmc.(注意，此步骤会自动擦除原系统的所有数据，如果你有配置文件要备份的，请注意备份)</p></li>
<li><p>安装过程成功完成后，气沉丹田，蛋定，然后，断掉N1电源, 拔掉U盘。再上电开机即可。</p></li>
<li><p>配置恢复 (具体方法见下面的&#34;配置的备份和恢复&#34;)</p></li>
<li><p>配置恢复后，重启一次。</p></li>
</ol>
<p>====================================================================================</p>
<h2><a name="faq2" class="anchor" href="#faq2" rel="nofollow" aria-hidden="true"><span class="octicon octicon-link"></span></a>
FAQ2</h2>
<p>为什么我刷机成功了，qb 或 tr 等还是黄色？</p>
<p>这不是成功，这是刷机失败的标志。</p>
<p>写盘有问题。权限问题导致qb没能启动，从而dashboard读取不到qb的配置而启动失败。
重新写盘吧。写完之后，别动！赶紧拔出来。</p>
<p>过早的插入U盘，或者，在U盘做好后，插入到android系统的盒子里后，会污染U盘，导致权限不正确，从而，
刷机之后很多文件权限不对。</p>
<p>更多FAQ见：<a href="https://gitee.com/8ox86/phicomm-n1-issue" rel="nofollow">https://gitee.com/8ox86/phicomm-n1-issue</a></p>
<h2><a name="配置的备份和恢复" class="anchor" href="#%E9%85%8D%E7%BD%AE%E7%9A%84%E5%A4%87%E4%BB%BD%E5%92%8C%E6%81%A2%E5%A4%8D" rel="nofollow" aria-hidden="true"><span class="octicon octicon-link"></span></a>
配置的备份和恢复</h2>
<p>====================================================================================</p>
<p>说明： 这里的sda1, sdb1 指的是设备名称，不是挂载点. 如指定 sdb1,则表示使用的是
/dev/sdb1 这个设备.</p>
<p><strong>备份</strong>：</p>
<p>确保有且仅有一个ext4 分区的可写的硬盘已经挂在N1上，</p>
<p>（PT用户注意：执行以下命令会关闭所有daemon, 因此，确保qb 你已经在web
ui手动点击暂停了所有种子。要不然会红种。。。）</p>
<p>然后执行</p>
<pre><code>cfg-backup
</code></pre>
<p>（如果你连接了两个以上的硬盘，比如你想指定备份到 sda1
这个设备，那么可以这样：cfg-backup sda1)</p>
<p>刷完机之后，从备份恢复：</p>
<p>确保前面备份用的那个ext4 分区的硬盘已经挂在N1上，确保有且仅有一个USB设备挂在N1上面，</p>
<p>然后执行</p>
<pre><code>cfg-recovery
</code></pre>
<p>默认不加参数执行，是备份到sda1这个分区，恢复也是.</p>
<p>（如果你有多个分区或硬盘，也可以在后面加参数，比如想从sdb1恢复，则执行 cfg-recovery
sdb1）</p>
<p>====================================================================================</p>
<h2><a name="默认用户名密码-访问url及端口说明" class="anchor" href="#%E9%BB%98%E8%AE%A4%E7%94%A8%E6%88%B7%E5%90%8D%E5%AF%86%E7%A0%81-%E8%AE%BF%E9%97%AEurl%E5%8F%8A%E7%AB%AF%E5%8F%A3%E8%AF%B4%E6%98%8E" rel="nofollow" aria-hidden="true"><span class="octicon octicon-link"></span></a>
默认用户名密码、访问URL及端口说明</h2>
<hr>
<p>假设N1的IP为: 192.168.8.201</p>
<hr>
<p>dashboard登录地址为： <code>http://192.168.8.201</code></p>
<p>默认用户名：<code>root</code> 密码： <code>root</code></p>
<p>其它信息:</p>
<pre><code>ssh 默认 端口 22, 用户名root, 密码root
ftp 默认 端口 21, 用户名root, 密码root
</code></pre>
<hr>
<hr>
<p>如果多次写盘（正确的工具，正确的操作）仍没能成功进入web ui，</p>
<p>请检测是否降级，或者操作是否有问题。</p>
<p>降级可以参考：<a href="https://gitee.com/8ox86/phicomm-n1-issue/blob/master/downgrade-n1.md" rel="nofollow">v2.27 , v2.28 降级教程</a></p>
<p>如果多次写盘（正确的工具，正确的操作）仍没能成功”全绿“，</p>
<p>请仔细再看看这个文档，是不是有什么步骤没按说明来。</p>
<hr>
<hr>
<p>！！！ 特别提醒 ！！！</p>
<p>使用qb, aria, tr 等下载器时，自己一定要设置下载目录为外接磁盘！</p>
<p>不要用默认的路径就开始下载东西！</p>
<hr>
<hr>
<p>默认开机自动走有线网口dhcp获取IP,</p>
<p>如果你的路由器没开dhcp, 那么,</p>
<p>会自动退回到原厂设定的固定IP: 192.168.8.88</p>
<hr>
<p>qb 默认web ui: <code>http://192.168.8.201:8083/</code></p>
<p>默认用户名: <code>admin</code></p>
<p>默认密码: <code>adminadmin</code></p>
<hr>
<p>tr 默认web地址: <code>http://192.168.8.201:9091/</code></p>
<p>第一次用,注意在dashboard设置 <a href="http://192.168.8.201/appcfg/transmission" rel="nofollow">http://192.168.8.201/appcfg/transmission</a></p>
<p>默认用户名: <code>admin</code></p>
<p>默认密码: 自己设置</p>
<p>默认局域网内是不需要密码就能访问的，如果需要密码认证的，自己修改配置:</p>
<p><code>rpc-authentication-required</code> <code>true</code></p>
<hr>
<p>filebrowser web 地址: <code>https://192.168.8.201:8081/</code></p>
<p>默认用户名: <code>admin</code></p>
<p>默认密码: <code>admin</code></p>
<hr>
<p>Syncthing web 地址: <code>http://192.168.8.201:8384/</code></p>
<p>默认用户名: 无</p>
<p>默认密码: 无</p>
<p>设置web ui用户:</p>
<p>右上角依次点击: 操作=&gt; 设置 =&gt; 图形用户界面 , 填写 &#39;图形管理界面用户名&#39; 和
&#39;图形管理界面密码&#39;, 保存.</p>
<hr>
<p>aria2 web 地址: <code>http://192.168.8.201/apps/AriaNg</code></p>
<hr>
<p>smb 需要进 <code>http://192.168.8.201/appcfg/smb-share</code> 设置共享目录.</p>
<p>硬盘默认会挂载到 <code>/media/xxxx</code> , 因此打路径时你只要打 <code>/media/</code> 就会自动提示.</p>
<p>如果不是两个全绿的运行状态,在你配置好的情况下,</p>
<p>在主配置页面 <code>http://192.168.8.108/appcfg/smb</code> 点一下save就会重启smb变绿.</p>
<p><strong>关于smb的用户配置说明</strong>:</p>
<p>这原本是你应该看smb的文档手册解决的问题,因为这些理念和约定,是smb程序设定的.</p>
<p>如果你不了解这个,那你配置上可能会有麻烦.</p>
<ol>
<li><p>里面有一个名字叫root的用户,这个是最高权限级别的.拥有对任何文件的操作权限.
它的smb密码,跟你登录ssh的root用户的密码,是分开的,是两回事.</p></li>
<li><p>smb里可以新建其它用户和共享.可以分配不同的权限,给不同的目录.</p></li>
</ol>
<p>以默认的设置举例说明（注意这里的root和admin用户之间有一个英文空格，这里的admin用户是自己新建另外一个用户）:</p>
<table>
<thead>
<tr>
<th align="left">Name</th>
<th align="left">Comment</th>
<th align="left">Path</th>
<th align="left">Writeable</th>
<th align="left">Valid Users</th>
<th align="left">Invalid Users</th>
<th align="left">Read List</th>
<th align="left">Write List</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">share</td>
<td align="left">share</td>
<td align="left">/media/my-movie</td>
<td align="left">no</td>
<td align="left">root admin</td>
<td align="left"></td>
<td align="left">root admin</td>
<td align="left">root admin</td>
</tr>
</tbody>
</table>
<p><code>Name</code>表示出现在客户端访问里的名字, 如你可以改成myshare.<br>
<strong>注意这个必须是唯一的!也就是说你不能弄两个相同的Name!</strong></p>
<p><code>Comment</code>
只是个注释,提醒自己用的,让自己别忘记设置这个目录是干嘛的.<br>
<code>Path</code> 表示要共享的目录的绝对路径.
一定要是真实存在的路径.</p>
<p><code>Writeable no</code> 表示默认是不给写权限的</p>
<p><code>Valid Users</code>
表示这个共享允许哪些用户. 相反,<code>Invalid Users</code>则表示不允许的.</p>
<p><code>Read List</code>
为可读用户列表</p>
<p><code>Write List</code> 为可写用户列表.</p>
<p>看完这些说明,你应该明白了默认的那个设置,为什么是那样的了.</p>
<hr>
<p>frp 需要进 <a href="http://192.168.8.201/appcfg/frp" rel="nofollow">http://192.168.8.201/appcfg/frp</a> 配置<code>Server Addr</code>和 <code>Auth
Token</code>等. 如果没有服务端,可用一键部署工具: <a href="https://frps-deploy.80x86.io" rel="nofollow">https://frps-deploy.80x86.io</a>
快捷安装.</p>
<p><code>Subdomain/CustomDomain</code> 字段是自适应的。</p>
<p>如果填写的是 abc 之类的，则是<code>Subdomain</code>.
如果你填写的是 <code>a.b.c</code>之类的(比如 foo.t.example.com)，</p>
<p>则会自动识别为<code>CustomDomain</code>,</p>
<p>具体填写什么根据你的服务器配置来。</p>
<p>大部分免费服务器不支持<code>Subdomain</code>。</p>
<p>如果你是用我的自动部署工具安装的frps，那么默认是支持Subdomain的.</p>
<hr>
<p>root密码可进 <a href="http://192.168.8.201/admin/system/admin" rel="nofollow">http://192.168.8.201/admin/system/admin</a>
修改,同时可以在这里加自己的公钥证书,实现免密码登录ssh.</p>
<hr>
<p>--EOF</p>
</article></body></html>]]></content>
    </entry>
</feed>